# When the `gradlew assembleStubRelease` command is run, an APK is generated. If installed, it would silently exit upon running due to having no bytecode attached. It also has the package name com.samtupy.nvgt.stub, which is not ideal.
# Thus, given gradle's intermediate build outputs, we will generate not an APK, but the skeliton of one with .flat resources and a plaintext AndroidManifest.xml which will be rebuilt with a user's custom package name by nvgt. Literally if we didn't need to rename com.samtupy.nvgt.stub to com.user.theirgame, this entire fiasco would be entirely unneeded, we could just use the APK generated by gradle simply adding bytecode.bin to it and re-signing it. *sigh I suppose such is not to be though, would love someone to come along and show me a better way of doing this sans modifying the bytes of resources.arsc and the binary AndroidManifest.xml directly.
# If Gradle's intermediate build directory proves to be too unstable across versions and operating systems, we'll rework this script to read as much as possible directly from Gradle's output APK file instead of the intermediate build outputs used to create it.
# NVGT - NonVisual Gaming Toolkit (https://nvgt.dev)
# Copyright (c) 2022-2025 Sam Tupy
# license: zlib

import os, shutil, sys, zipfile

if len(sys.argv) < 3:
	print("makestub: needed variant name and path to build directory")
	sys.exit(1)
variant = sys.argv[1]
variant_cap = variant[0].upper()+ variant[1:]
build_dir = sys.argv[2]
shutil.make_archive(os.path.join(build_dir, "tmp", "res"), "zip", os.path.join(build_dir, "intermediates", "merged_res", variant))
if not os.path.isdir(os.path.join(os.path.dirname(__file__), "..", "release", "stub")): os.mkdir(os.path.join(os.path.dirname(__file__), "..", "release", "stub"))
zip_out = zipfile.ZipFile(os.path.join(os.path.dirname(__file__), "..", "release", "stub", "nvgt_android" + ("_debug" if not variant.endswith("Release") else "") + ".bin"), "w", zipfile.ZIP_DEFLATED)
zip_out.write(os.path.join(build_dir, "tmp", "res.zip"), "res.zip")
if os.path.isfile(os.path.join("build", "intermediates", "dex", variant, "mergeDex" + variant_cap, "classes.dex")):
	zip_out.write(os.path.join("build", "intermediates", "dex", variant, "mergeDex" + variant_cap, "classes.dex"),"classes.dex")
elif os.path.isdir(os.path.join("build", "intermediates", "dex", variant, "mergeProjectDex" + variant_cap)):
	dex_counter = 1
	for root, dirs, files in os.walk(os.path.join("build", "intermediates", "dex", variant, "mergeProjectDex" + variant_cap)):
		for f in files:
			if not f.endswith(".dex"): continue
			zip_out.write(os.path.join(root, f), "classes" + (str(dex_counter) if dex_counter > 1 else "") + ".dex")
			dex_counter += 1
zip_out.write(os.path.join(build_dir, "intermediates", "merged_manifests", variant, f"process{variant_cap}Manifest", "AndroidManifest.xml"),"AndroidManifest.xml")
native_libpath = os.path.join(build_dir, "intermediates", "stripped_native_libs", variant, f"strip{variant_cap}DebugSymbols", "out", "lib")
for root, dirs, files in os.walk(native_libpath):
	for f in files:
		zip_out.write(os.path.join(root, f), os.path.join(root[len(native_libpath)-3:], f))
zip_out.close()
os.remove(os.path.join(build_dir, "tmp", "res.zip"))
